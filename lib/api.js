const io = require("socket.io-client"), { v4: uuidv4 } = require("uuid"); class AudioTranscriptionSDK { #a; #b; #c; #d; #e; #f; #g; #h; #i; #j; #k; #l; #m; #n; #o; #p; #q; #r; #s; constructor({ api_key: t, connectionId: e, contextLength: i, maxReconnectAttempts: s = 5, reconnectInterval: n = 5e3, debug: o = !1 }) { this.#t({ api_key: t, contextLength: i }), this.#o = "http://15.207.18.197", this.#e = e || uuidv4(), this.#f = [], this.#h = Date.now(), this.#i = !1, this.#j = !1, this.#k = !1, this.#l = t, this.#m = i, this.#p = 0, this.#q = s, this.#r = n, this.#s = o, this.#u("Initializing AudioTranscriptionSDK", { connectionId: e, contextLength: i, maxReconnectAttempts: s, reconnectInterval: n, debug: o }), this.#v() } #u(t, e = {}) { if (this.#s) { let i = new Date().toISOString(); console.log(`[${i}] [AudioTranscriptionSDK] ${t}`, e) } } #t({ api_key: s, contextLength: n }) { if (!s || "string" != typeof s) throw Error("Invalid api_key. Must be a non-empty string."); if (!Number.isInteger(n) || n < 2 || n > 5) throw Error("Invalid contextLength. Must be an integer between 2 and 5.") } #v() { this.#u("Initializing socket connection"), this.#a = io(this.#o), this.#w(), this.#a.emit("join", { connection_id: this.#e, api_key: this.#l }) } #w() { this.#a.on("connect", () => { this.#u("Socket connected successfully"), this.#j = !0, this.#p = 0 }), this.#a.on("disconnect", () => { this.#u("Socket disconnected"), this.#j = !1, this.#x() }), this.#a.on("transcription", t => { this.#u("Received transcription", { responseTime: Date.now() - this.#n }), this.#b && this.#b(t.transcription) }), this.#a.on("questions", t => { this.#u("Received questions", { questions: t }), this.#c && this.#c({ transcript: t.transcription, questions: t.questions }) }), this.#a.on("joined", () => { this.#u("Successfully joined conversation", { connectionId: this.#e }) }), this.#a.on("leave", t => { this.#u("Received leave signal", { data: t }), this.stopListening() }), this.#a.on("transcription_error", t => { this.#u("Transcription error occurred", { error: t }), this.#d && this.#d(t) }), this.#a.on("error", t => { this.#u("Socket error occurred", { error: t }), this.#d && this.#d(t) }) } #x() { this.#p < this.#q ? (this.#p++, this.#u("Attempting to reconnect", { attempt: this.#p, maxAttempts: this.#q }), setTimeout(() => this.#v(), this.#r)) : (this.#u("Max reconnection attempts reached", { attempts: this.#p }), this.#d && this.#d(Error("Max reconnection attempts reached"))) } stopListening() { this.#u("Stopping listening"), this.#j && this.#a.disconnect(), this.#j = !1 } init() { if (this.#u("Initializing audio stream"), !this.#j) throw Error("Socket is not connected. Please ensure the SDK is properly initialized."); this.#g = Buffer.alloc(0), this.#h = Date.now(), this.#i = !1, this.#k = !0 } sendAudioStream(t) { if (!this.#j) throw Error("Socket is not connected. Please ensure the SDK is properly initialized."); if (!t || !(t instanceof Buffer)) throw Error("Invalid audio chunk. Must be a Buffer."); if (!this.#k) throw Error("Initial setup required. Please call init() before sending audio."); this.#g = Buffer.concat([this.#g, t]), this.#i || this.#y(), this.#z() } #y() { let o = Date.now(); o - this.#h >= 200 && (this.#f.push(this.#g), this.#h = o, this.#g = Buffer.alloc(0), this.#i = !0, this.#u("First chunk received and processed")) } #z() { let c = Date.now(); if (c - this.#h >= 3e3) { let r = this.#g.byteLength - 176400 * Math.floor((c - this.#h) / 1e3), h = this.#g.slice(r); this.#A(h), this.#h = c, this.#g = Buffer.alloc(0), this.#u("Audio chunk sent", { chunkSize: h.length }) } } leave() { this.#u("Leaving conversation"), this.#j && this.#a.emit("leave", { connection_id: this.#e }), this.stopListening() } async #A(a) { this.#f.push(a); let l = this.#B(), u = Buffer.concat(l), f = this.#C(u); this.#u("Sending audio chunk to server", { bufferSize: u.length }), this.#n = Date.now(), this.#a.emit("audio_transcribe", { audio: f, context: this.#m, connection_id: this.#e }) } #B() { let d = this.#f[0], p = [this.#f[0]]; if (this.#f.length > this.#m) for (let g = this.#f.length - this.#m + 1; g < this.#f.length; g++)p.push(this.#f[g]); else for (let k = 1; k < this.#f.length; k++)p.push(this.#f[k]); return p[p.length - 1] !== d && p.push(d), p } #C(b) { return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength) } onTranscription(t) { if ("function" != typeof t) throw Error("Transcription callback must be a function"); this.#b = t, this.#u("Transcription callback set") } onQuestion(t) { if ("function" != typeof t) throw Error("Question callback must be a function"); this.#c = t, this.#u("Question callback set") } onError(t) { if ("function" != typeof t) throw Error("Error callback must be a function"); this.#d = t, this.#u("Error callback set") } isConnected() { return this.#j } setDebugMode(t) { this.#s = t, this.#u("Debug mode set", { debug: t }) } } module.exports = AudioTranscriptionSDK;